
#pragma once

#include <list>

#include <mutex>
#include <thread>

namespace std {

template <typename _Ty, class _Alloc = allocator<_Ty>>
class thread_list : public list<_Ty, _Alloc> {
  typedef thread_list<_Ty, _Alloc> _Myt;
  typedef list<_Ty, _Alloc> _Mybase;

public:
  typedef typename _Mybase::value_type value_type;
  typedef typename _Mybase::allocator_type allocator_type;

  typedef typename _Mybase::size_type size_type;
  typedef typename _Mybase::difference_type difference_type;

  typedef typename _Mybase::reference reference;
  typedef typename _Mybase::const_reference const_reference;
  typedef typename _Mybase::iterator iterator;
  typedef typename _Mybase::const_iterator const_iterator;
  typedef typename _Mybase::pointer pointer;
  typedef typename _Mybase::const_pointer const_pointer;

  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  thread_list(size_type _MaxSize = (size_type)-1) : _Mybase(), _max_size(_MaxSize) {}
  thread_list(_Myt const & _Right) = delete;
  thread_list(_Mybase const & _Right) = delete;
  _Myt & operator=(_Mybase const & _Right) = delete;

  void push_back(_Ty && _Val) {
    while (this->size() >= _max_size) { wait(); }
    _mutex.lock();
    _Mybase::push_back(_Val);
    _mutex.unlock();
  }
  void push_back(_Ty const & _Val) {
    while (this->size() >= _max_size) { wait(); }
    _mutex.lock();
    _Mybase::push_back(_Val);
    _mutex.unlock();
  }

  inline reference front() {
    while (this->empty()) { wait(); }
    return _Mybase::front();
  }
  inline const_reference front() const {
    while (this->empty()) { wait(); }
    return _Mybase::front();
  }

  void pop_front() {
    while (this->empty()) { wait(); }
    _mutex.lock();
    _Mybase::pop_front();
    _mutex.unlock();
  }

private:
  void wait() {
    // this_thread::sleep_for(chrono::milliseconds(100));
    this_thread::yield();
  }

  size_type const _max_size;
  mutex _mutex;
};

} // namespace std
